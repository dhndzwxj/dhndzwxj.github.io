<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start -->
<link rel="stylesheet" href="css/bilicard.css">
<!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>python2 与 python3的区别 | 小荷才露尖尖角</title><meta name="author" content="揭晓"><meta name="copyright" content="揭晓"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="几乎所有的python2程序都需要一些修改才能正常的运行在python3的环境下。为了简化这个转换过程，Python3自带了一个2to3的实用脚本.这个脚本会将python2程序源文件作为输入，然后自动转换到python３．但并不是所有内容都可以自动转换。  print语句 python2中print是一个语句，不论想输出什么，直接放到print关键字后面即可。python3里，print()是一">
<meta property="og:type" content="article">
<meta property="og:title" content="python2 与 python3的区别">
<meta property="og:url" content="https://dhndzwxj.github.io/2928949794.html">
<meta property="og:site_name" content="小荷才露尖尖角">
<meta property="og:description" content="几乎所有的python2程序都需要一些修改才能正常的运行在python3的环境下。为了简化这个转换过程，Python3自带了一个2to3的实用脚本.这个脚本会将python2程序源文件作为输入，然后自动转换到python３．但并不是所有内容都可以自动转换。  print语句 python2中print是一个语句，不论想输出什么，直接放到print关键字后面即可。python3里，print()是一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dhndzwxj.github.io/private_img/banner2.gif">
<meta property="article:published_time" content="2020-11-15T04:17:19.000Z">
<meta property="article:modified_time" content="2023-03-07T10:32:10.780Z">
<meta property="article:author" content="揭晓">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="python">
<meta property="article:tag" content="代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dhndzwxj.github.io/private_img/banner2.gif"><link rel="shortcut icon" href="/private_img/favicon.png"><link rel="canonical" href="https://dhndzwxj.github.io/2928949794.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":50,"position":"top","messagePrev":"本文上次更新距离今天已经过去","messageNext":"天, 文中内容可能已经过时，望周知。"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python2 与 python3的区别',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-07 18:32:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.loli.net/css2?family=Noto+Serif+SC:wght@400;500;700&display=swap" rel="stylesheet"><link href="https://fonts.loli.net/css2?family=Ma+Shan+Zheng:wght@400;500;700&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/wave.css?v1"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="atom.xml" title="小荷才露尖尖角" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="../private_img/yuyingnan.jpg" onerror="onerror=null;src='/private_img/404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="../archives/"><div class="headline">文章</div><div class="length-num">272</div></a><a href="../tags/"><div class="headline">标签</div><div class="length-num">644</div></a><a href="../categories/"><div class="headline">分类</div><div class="length-num">74</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="../about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-laptop-house"></i><span> 结构</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="../categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></li><li><a class="site-page child" href="../archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="../tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="../air-conditioner/"><i class="fa-fw fas fa-wind"></i><span> 便携小空调</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/private_img/banner2.gif')"><nav id="nav"><span id="blog-info"><a href="../index.html" title="小荷才露尖尖角"><span class="site-name">小荷才露尖尖角</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="../../../"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="../about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-laptop-house"></i><span> 结构</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="../categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></li><li><a class="site-page child" href="../archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="../tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="../air-conditioner/"><i class="fa-fw fas fa-wind"></i><span> 便携小空调</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">python2 与 python3的区别</h1><div id="post-meta"><div class="meta-firstline"><i class="fa-solid fa-user"></i><span class="post-meta-author">揭晓</span><span class="post-meta-date"><span class="post-meta-separator">|</span><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-15T04:17:19.000Z" title="发表于 2020-11-15 12:17:19">2020-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-07T10:32:10.780Z" title="更新于 2023-03-07 18:32:10">2023-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="categories/%E6%9D%82%E6%8A%80/">杂技</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="categories/%E6%9D%82%E6%8A%80/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="python2 与 python3的区别"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>几乎所有的python2程序都需要一些修改才能正常的运行在python3的环境下。为了简化这个转换过程，Python3自带了一个2to3的实用脚本.这个脚本会将python2程序源文件作为输入，然后自动转换到python３．但并不是所有内容都可以自动转换。</p>
<h2 id="print语句"><a class="markdownIt-Anchor" href="#print语句"></a> print语句</h2>
<p>python2中print是一个语句，不论想输出什么，直接放到print关键字后面即可。python3里，print()是一个函数，像其他函数一样，print()需要你将要输出的东西作为参数传给它。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">print</td>
<td style="text-align:left">print()</td>
<td style="text-align:left">输出一个空白行，python3需要调用不带参数的print()</td>
</tr>
<tr>
<td style="text-align:left">print 1</td>
<td style="text-align:left">print(1)</td>
<td style="text-align:left">输出一个值，将值传入print()函数</td>
</tr>
<tr>
<td style="text-align:left">print 1, 2</td>
<td style="text-align:left">print(1,2)</td>
<td style="text-align:left">输出使用空格分割的两个值，使用两个参数调用print()</td>
</tr>
<tr>
<td style="text-align:left">print 1, 2,</td>
<td style="text-align:left">print(1,2, end=’ ')</td>
<td style="text-align:left">python2中如果使用一个,作为print结尾，将会用空格分割输出的结果，然后在输出一个尾随的空格，而不输回车。python3里，把end=’ ’ 作为一个关键字传给print()可以实现同样的效果，end默认值为’\n’,所以通过重新指定end参数的值，可以取消在末尾输出回车符号</td>
</tr>
<tr>
<td style="text-align:left">print &gt;&gt; sys.stderr, 1, 2, 3</td>
<td style="text-align:left">print(1, 2, 3, file=sys.stderr</td>
<td style="text-align:left">python2中，可以通过&gt;&gt;pipe_name语法，把输出重定向到一个管道，比如sys.stderr.在python3里，可以通过将管道作为关键字参数file的值传递给print()完成同样的功能。</td>
</tr>
</tbody>
</table>
<h2 id="unicode字符串"><a class="markdownIt-Anchor" href="#unicode字符串"></a> UNICODE字符串</h2>
<p>python2中有两种字符串类型：Unicode字符串和非Unicode字符串。Python3中只有一种类型：Unicode字符串。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u’PapayaWhip’</td>
<td style="text-align:left">‘PapayaWhip’</td>
<td style="text-align:left">python2中的Unicode字符串在python3即为普通字符串</td>
</tr>
<tr>
<td style="text-align:left">ur’PapayaWhip\foo’</td>
<td style="text-align:left">r’PapayWhip\foo’</td>
<td style="text-align:left">Unicode原始字符串(使用这种字符串，python不会自动转义反斜线&quot;&quot;)也被替换为普通的字符串，因为在python3里，所有原始字符串都是以unicode编码的。</td>
</tr>
</tbody>
</table>
<h2 id="全局函数unicode"><a class="markdownIt-Anchor" href="#全局函数unicode"></a> 全局函数UNICODE()</h2>
<p>python２有两个全局函数可以把对象强制转换成字符串:unicode()把对象转换成unicode字符串，还有str()把对象转换为非Unicode字符串。Python3只有一种字符串类型，unicode字符串，所以str()函数即可完成所有的功能。</p>
<h2 id="long长整型"><a class="markdownIt-Anchor" href="#long长整型"></a> LONG长整型</h2>
<p>python2有非浮点数准备的int和long类型。int类型最大值不能超过sys.maxint，而且这个最大值是平台相关的。可以通过在数字的末尾附上一个Ｌ来定义长整型，显然，它比int类型表示的数字范围更大。在python3里，只有一种整数类型int,大多数情况下，和python２中的长整型类似。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x = 1000000000000L</td>
<td style="text-align:left">x = 1000000000000</td>
<td style="text-align:left">python2中的十进制长整型在python3中被替换为十进制普通整数</td>
</tr>
<tr>
<td style="text-align:left">x = 0xFFFFFFFFFFFFL</td>
<td style="text-align:left">x = 0xFFFFFFFFFFFF</td>
<td style="text-align:left">python2里的十六进制长整型在python3里被替换为十六进制的普通整数</td>
</tr>
<tr>
<td style="text-align:left">long(x)</td>
<td style="text-align:left">int(x)</td>
<td style="text-align:left">python3没有long()</td>
</tr>
<tr>
<td style="text-align:left">type(x) is long</td>
<td style="text-align:left">type(x) is int</td>
<td style="text-align:left">python3用int判断是否为整型</td>
</tr>
<tr>
<td style="text-align:left">isinstance(x, long)</td>
<td style="text-align:left">isinstance(x, int)</td>
<td style="text-align:left">int检查整数类型</td>
</tr>
</tbody>
</table>
<h2 id="比较运算符"><a class="markdownIt-Anchor" href="#比较运算符"></a> &lt;&gt;比较运算符</h2>
<p>Python2支持&lt;&gt;作为!=的同义词，　python3只支持!=, 不再支持&lt;&gt;</p>
<h2 id="字典类方法has_key"><a class="markdownIt-Anchor" href="#字典类方法has_key"></a> 字典类方法HAS_KEY()</h2>
<p>Python2中，字典对象has_key()方法测试字典是否包含指定的键。python3不再支持这个方法，需要使用in.</p>
<h2 id="返回列表的字典类方法"><a class="markdownIt-Anchor" href="#返回列表的字典类方法"></a> 返回列表的字典类方法</h2>
<p>在python2里，许多字典类方法的返回值是列表。最常用方法有keys, items和values。python3，所有以上方法的返回值改为动态试图。在一些上下文环境里，这种改变不会产生影响。如果这些方法的返回值被立即传递给另外一个函数，而且那个函数会遍历整个序列，那么以上方法的返回值是列表或视图并不会产生什么不同。如果你期望获得一个被独立寻址元素的列表，那么python3的这些改变将会使你的代码卡住，因为视图不支持索引。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a_dictionary.keys()</td>
<td style="text-align:left">list(a_dictionary.keys())</td>
<td style="text-align:left">使用list()将keys 返回值转换为一个静态列表</td>
</tr>
<tr>
<td style="text-align:left">a_dictionary.items()</td>
<td style="text-align:left">list(a_dictonary.items())</td>
<td style="text-align:left">将items返回值转为列表</td>
</tr>
<tr>
<td style="text-align:left">a_dictionary.iterkeys()</td>
<td style="text-align:left">iter(a_dictionary.keys())</td>
<td style="text-align:left">python3不再支持iterkeys,使用iter()将keys()的返回值转换为一个迭代器</td>
</tr>
<tr>
<td style="text-align:left">[i for i in a_dictionary.iterkeys()]</td>
<td style="text-align:left">[ i for i in a_dictonary.keys()]</td>
<td style="text-align:left">不需要使用额外的iter()，keys()方法返回的是可迭代的</td>
</tr>
<tr>
<td style="text-align:left">min(a_dictionary.keys())</td>
<td style="text-align:left">no change</td>
<td style="text-align:left">对min(),max(),sum(),list(),tuple(),set(),sorted(),any()和all()同样有效</td>
</tr>
</tbody>
</table>
<h2 id="重命名或重新组织的模块"><a class="markdownIt-Anchor" href="#重命名或重新组织的模块"></a> 重命名或重新组织的模块</h2>
<p>从python2到python3，标准库里的一些模块已经被重命名。还有一些相互关联的模块也被组合或则重新组织，使得这种关联更有逻辑性。</p>
<p>HTTP</p>
<p>python3中几个相关的http模块被组合成一个单独的包，即http</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">import httplib</td>
<td style="text-align:left">import http.client</td>
<td style="text-align:left">http.client模块实现一个底层的库，可以用来请求和解析http</td>
</tr>
<tr>
<td style="text-align:left">import cookie</td>
<td style="text-align:left">import http.cookies</td>
<td style="text-align:left">http.cookie提供一个pythonic接口进行cookies操作</td>
</tr>
<tr>
<td style="text-align:left">import cookielib</td>
<td style="text-align:left">import http.cookiejar</td>
<td style="text-align:left">http.cookiejar可以操作cookies文件</td>
</tr>
<tr>
<td style="text-align:left">import BaseHTTPServer import SimpleHTTPServer import CGIHttpServer</td>
<td style="text-align:left">import http.server</td>
<td style="text-align:left">http.server实现了一个基本的http服务器</td>
</tr>
</tbody>
</table>
<p>URLLIB</p>
<p>python2中用来分析、编码和获取URL的模块，但是比较混乱，python3中，这些模块被重构，组合成为一个单独的包，即urllib</p>
<p>| python2 | python3 | 备注 | import urllib | import urllib.request, import urllb.parse, import urllib.error | | import urllib2 | import urllib.request, urllib.error | | import urlparse | import urllib.parse | | import robotparser | import urllib.robotparser | | from urllib import FancyURLopener | from urllib.rquest import FancyURLopener from urllib.parse | |from urllib2 import Request from urllib2 import HTTPError | from urllib.request import Request from urllib.error import HTTPError |</p>
<p>DBM</p>
<p>所有的DBM现在都在一个单独的包里，即dbm。如果需要其中某个特定的变体，比如GNU DBM,可以导入dbm包中合适的模块。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">import dbm</td>
<td style="text-align:left">import dbm.ndbm</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import gdbm</td>
<td style="text-align:left">import dbm.gnu</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import dbhash</td>
<td style="text-align:left">import dbm.bad</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import dumbdbm</td>
<td style="text-align:left">import dbm.dumb</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import anydbm import whichdb</td>
<td style="text-align:left">import dbm</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>XMLRPC</p>
<p>XML-RPC是一个通过HTTP协议执行远程RPC调用的轻重级方法。一些XML_RPC客户端和XML_RPC服务端的实现库组合成独立的包，xmlrpc.</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">import xmlrpclib</td>
<td style="text-align:left">import xmlrpc.client</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import DocXMLRPCServer import SimpleXMLRPCServer</td>
<td style="text-align:left">import xmlrpc.server</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>其他模块</p>
<table>
<thead>
<tr>
<th style="text-align:left">Python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">try: import cStringIO as StringIO except ImportError: import STringIO</td>
<td style="text-align:left">import io</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import cPickle as pickle except ImportError: import pickle</td>
<td style="text-align:left">import pickle</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import builtin</td>
<td style="text-align:left">import builtins</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import copy_reg</td>
<td style="text-align:left">import copyreg</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import Queue</td>
<td style="text-align:left">import queue</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import SocketServer</td>
<td style="text-align:left">import socketserver</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import ConfigParser</td>
<td style="text-align:left">import configparser</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import repr</td>
<td style="text-align:left">import reprlib</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import commands</td>
<td style="text-align:left">import subprocess</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>包内的相对导入</p>
<p>包是由一组相关联的模块共同组成的单个实体。在python２的时候，为了实现同一个包内模块的相互引用，你会使用import foo或者from foo import Bar。<a target="_blank" rel="noopener" href="http://xn--Python2foo-jy4pi3s7sdluumwc5y3c9az31rpx5fr6zaz79cvlvbtba.py">Python2解释器会先在当前目录里搜索foo.py</a>，然后再去python搜索路径(sys.path)搜索。在python3里这个过程有一点不同。Python3不会首先在当前路径搜索，它会直接在Python的搜索路径里寻找。如果想要包里的一个模块导入包的另一个模块，需要显式的提供两个模块的相对路径。</p>
<p>迭代器方法NEXT()</p>
<p>python2里，迭代器有一个next()方法，用来返回序列的下一项。在python3里同样成立。但是有一个新的全局的函数next(),它使用一个迭代器作为参数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">anIterator.next()</td>
<td style="text-align:left">next(anIterator)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_function_that_returns_an_iterator().next()</td>
<td style="text-align:left">next(a_function_that_returns_an_iterator())</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class A: def next(self): pass</td>
<td style="text-align:left">class A : def next(self): pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class A: def next(self, x, y): pass</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">next = 42 for an_iterator in a_sequence_of_iterators: an_iterator.next()</td>
<td style="text-align:left">next =42 for an interator in a_sequence_of_iterators: an_iterator.next()</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>全局函数FILTER()</p>
<p>在python2里，filter()方法返回一个列表，这个列表是通过一个返回值为True或False的函数来检测序列里的每一项的道德。在python3中，filter()函数返回一个迭代器，不再是列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">filter(a_function, a_sequence)</td>
<td style="text-align:left">list(filter(a_function, a_sequence))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">list(filter(a_function, a_sequence))</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">filter(None, a_sequence)</td>
<td style="text-align:left">[i for i in a_sequence if i ]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">for i in filter(None, a_sequence):</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[i for i in filter(a_function, a_sequence)]</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>MAP()</p>
<p>跟filter()的改变一样，map()函数现在返回一个迭代器,python2中返回一个列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">map(a_function,‘PapayaWhip’</td>
<td style="text-align:left">list(map(a_function, ‘PapayaWhip’))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">map(None, ‘PapayaWhip’</td>
<td style="text-align:left">list(‘PapayWhip’)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">map(lambda x: x+1, range(42))</td>
<td style="text-align:left">[x+1 for x in range(42)]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">for i in map(a_function, a_sequence):</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[i for i in map(a_function, a_sequence)]</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>REDUCE()</p>
<p>在python3里，reduce()函数已经从全局名字空间移除，现在被放置在fucntools模块里。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">reduce(a,b,c)</td>
<td style="text-align:left">from functools import reduce reduce(a, b, c)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>APPLY()</p>
<p>python2有一个叫做apply()的全局函数，它使用一个函数f和一个列表[a,b,c]作为参数，返回值是f(a,b,c).可以直接调用这个函数，在列表前添加一个星号作为参数传递给它来完成同样的事情。在python3里，apply()函数不再存在；必须使用星号标记。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">apply(a_function, a_list_of_args</td>
<td style="text-align:left">a_function(*a_list_of_args)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">apply(a_function, a_list_of_args, a_dictionary_of_named_args)</td>
<td style="text-align:left">a_function(*a_list_of_args, **a_dictionary_of_named_args)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">apply(a_function, a_list_of_args + z)</td>
<td style="text-align:left">a_function(*a_list_of_args + z)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">apply(aModule.a_function, a_list_of_args)</td>
<td style="text-align:left">aModule.a_function(*a_list_of_args)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>INTERN()  python2里，你可以用intern()函数作用在一个字符串上来限定intern以达到性能优化，python3里，intern()函数转移到sys模块里。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">intern(aString)</td>
<td style="text-align:left">sys.intern(aString)</td>
<td style="text-align:left">--------</td>
</tr>
</tbody>
</table>
<p>EXEC</p>
<p>就像print语句在python3里变成了一个函数一样，exec语句也是这样的。exec()函数使用一个包含任意python代码的字符串作为参数，然后像执行语句或表达式一样执行它。exec()跟eval()是相似，但exec()更加强大并具有挑战性。eval()函数只能执行单独一条表达式，但是exec()能够执行多条语句，导入(import),函数声明－实际上整个python程序的字符串表示也可以。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">exec codeString</td>
<td style="text-align:left">exec(codeString)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">exec codeString in a_global_namespace</td>
<td style="text-align:left">exec(codeString, a_global_namespace)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">exec_codeString in a_global_namespace, a_local_namespace</td>
<td style="text-align:left">exec(codeString, a_global_namespace, a_local_namespace</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>execfile</p>
<p>python２中的execfile语句可以像执行python代码那样使用字符串。不同的是exec使用字符串，而execfile使用文件。在python3，execfile语句被去掉了。</p>
<p>REPR</p>
<p>在python2，为了得到一个任意对象的字符串表示，有一种把对象包装在反引号里(比如<code>x</code>)的特殊语法。在python3里，这种能力仍然存在，但是你不能再使用反引号获得这种字符串表示了，需要使用全局函数repr().</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x</code></td>
<td style="text-align:left">repr(x)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>'PapayaWhip' +</code>2``</td>
<td style="text-align:left">repr(‘PapayWhip’ + repr(2))</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>TRYEXCEPT语句</p>
<p>python２到python3，捕获异常的语法有些变化。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Python2</th>
<th style="text-align:left">Python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">try: import mymodule except ImportError, e pass</td>
<td style="text-align:left">try: import mymodule except ImportError as e: pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import mymodule except (RuntimeError, ImportError), e pass</td>
<td style="text-align:left">try: import mymodule except(RuntimeError, ImportError) as e: pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import mymodule except ImportError: pass</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import mymodule except: pass</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>RAISE</p>
<p>python3里，抛出自定义异常的语法有细微的变化。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">raise MyException</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">raise MyException, ‘error message’</td>
<td style="text-align:left">raise MyException(‘error message’)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">raise MyException, ‘error message’</td>
<td style="text-align:left">raise MyException(‘error message’).with_traceback(a_traceback)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">raise ‘error message’</td>
<td style="text-align:left">unsupported</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>生成器THROW</p>
<p>在python2里，生成器有一个throw()方法。调用a_generator.throw()会在生成器被暂停的时候抛出异常，然后返回由生成器函数获取的下一个值。python3中，这一功能仍然可用，但语法有一点不同。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a_generator.throw(MyException)</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_generator.throw(MyException, ‘error message’</td>
<td style="text-align:left">a_generator.throw(MyException(‘error message’))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_generator.throw(‘error message’)</td>
<td style="text-align:left">unsupported</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>XRANGE()</p>
<p>python２里，有两种方法获得一定范围内的数字：range(),返回一个列表，还有xrange(),返回一个迭代器。python3　里，range()返回迭代器，xrange()不再存在。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xrange(10)</td>
<td style="text-align:left">range(10)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_list = range(10)</td>
<td style="text-align:left">a_list= list(range(10))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[i for i in xrange(10)]</td>
<td style="text-align:left">[i for i in range(10)]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">for i in range(10):</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">sum(range(10))</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="raw_input和input"><a class="markdownIt-Anchor" href="#raw_input和input"></a> RAW_INPUT()和INPUT()</h2>
<p>python2有两个全局函数，用在命令行请求用户输入。第一个叫input()，它等待用户输入一个python表达式(然后返回结果)。第二个叫做raw_input(),用户输入什么他就返回什么。python3 通过input替代了他们。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">raw_input()</td>
<td style="text-align:left">input</td>
<td style="text-align:left">input替代了raw_input</td>
</tr>
<tr>
<td style="text-align:left">raw_input(‘prompt’)</td>
<td style="text-align:left">input(‘prompt’)</td>
<td style="text-align:left">python3仍然支持提示符参数</td>
</tr>
<tr>
<td style="text-align:left">input()</td>
<td style="text-align:left">eval(input))</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="函数属性func_"><a class="markdownIt-Anchor" href="#函数属性func_"></a> 函数属性FUNC_*</h2>
<p>python2,函数的代码可用访问到函数本身的特殊属性。python3为了一致性，这些特殊属性被重命名了。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a_function.func_name</td>
<td style="text-align:left">a_function.<strong>name</strong></td>
<td style="text-align:left">__name__属性包含了函数的名字</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_doc</td>
<td style="text-align:left">a_function.<strong>doc</strong></td>
<td style="text-align:left">__doc__包含了函数源代码定义的文档字符串</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_defaults</td>
<td style="text-align:left">a_function.<strong>defaults</strong></td>
<td style="text-align:left">是一个保存参数默认值的元组</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_dict</td>
<td style="text-align:left">a_function.<strong>dict</strong></td>
<td style="text-align:left">__dict__属性是一个支持任意函数属性的名字空间</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_closure</td>
<td style="text-align:left">a_function.<strong>closure</strong></td>
<td style="text-align:left">__closure__属性是由cell对象组成的元组，包含了函数对自由变量的绑定</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_globals</td>
<td style="text-align:left">a_function.<strong>globals</strong></td>
<td style="text-align:left">是对模块全局名字空间的引用</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_code</td>
<td style="text-align:left">a_function.<strong>code</strong></td>
<td style="text-align:left">是一个代码对象，表示编译后的函数体</td>
</tr>
</tbody>
</table>
<h2 id="io方法xreadlines"><a class="markdownIt-Anchor" href="#io方法xreadlines"></a> I/O方法XREADLINES()</h2>
<p>python2中，文件对象有一个xreadlines()方法，返回一个迭代器，一次读取文件的一行。这在for循环中尤其实用。python3中，xreadlines()方法不再可用。</p>
<h2 id="lambda函数"><a class="markdownIt-Anchor" href="#lambda函数"></a> lambda函数</h2>
<p>在python2中，可以定义匿名函数lambda函数，通过指定作为参数的元组的元素个数，使这个函数实际上能够接收多个参数。python2的解释器把这个元组&quot;解开“成命名参数，然后可以在lambda函数里引用它们。在python3中仍然可以传递一个元组为lambda函数的参数。但是python解释器不会把它当成解析成命名参数。需要通过位置索引来引用每个参数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">lambda (x,): x + f(x)</td>
<td style="text-align:left">lambda x1 : x1[0] + f(x1[0])</td>
<td style="text-align:left">注１</td>
</tr>
<tr>
<td style="text-align:left">lambda (x,y): x + f(y)</td>
<td style="text-align:left">lambda x_y : x_y[0] + f(x_y[1])</td>
<td style="text-align:left">注２</td>
</tr>
<tr>
<td style="text-align:left">lambda (x,(y,z)): x + y + z</td>
<td style="text-align:left">lambda x_y_z: x_y_z[0] + x_y_z[1][0]+ x_y_z[1][1]</td>
<td style="text-align:left">注３</td>
</tr>
<tr>
<td style="text-align:left">lambda x,y,z: x+y+z</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left">注４</td>
</tr>
</tbody>
</table>
<p>注１：如果定义了一个lambda函数，使用包含一个元素的元组作为参数，python3中，会被转换成一个包含到x1[0]的引用的lambda函数。x1是2to3脚本基于原来元组里的命名参数自动生成的。</p>
<p>注２：使用含有两个元素的元组(x,y)作为参数的lambda函数被转换为x_y,它有两个位置参数，即x_y[0]和x_y[1]</p>
<p>注３：2to3脚本可以处理使用嵌套命名参数的元组作为参数的lambda函数。产生的结果有点晦涩，但python3下和python2的效果是一样的。</p>
<p>注４：可以定义使用多个参数的lambda函数。语法在python3同样有效</p>
<h2 id="特殊的方法属性"><a class="markdownIt-Anchor" href="#特殊的方法属性"></a> 特殊的方法属性</h2>
<p>在python2里，类方法可以访问到定义他们的类对象,也能访问方法对象本身。im_self是类的实例对象；im_func是函数对象，im_class是类本身。在python3里，这些属性被重命名，以遵循其他属性的命名约定。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">aClassInstance.aClassMethod.im_func</td>
<td style="text-align:left">aClassInstance.aClassMethod.<strong>func</strong></td>
</tr>
<tr>
<td style="text-align:left">aClassInstance.aClassMethod.im_self</td>
<td style="text-align:left">aClassInstance.aClassMethod.<strong>self</strong></td>
</tr>
<tr>
<td style="text-align:left">aClassInstance.aClassMethod.im_class</td>
<td style="text-align:left">aClassInstance.aClassMethod.<strong>self</strong>.<strong>class</strong></td>
</tr>
</tbody>
</table>
<h2 id="__nonzero__特殊方法"><a class="markdownIt-Anchor" href="#__nonzero__特殊方法"></a> __NONZERO__特殊方法</h2>
<p>在python2里，可以创建自己的类，并使他们能够在布尔上下文中使用。举例来说，可以实例化这个类，并把这个实例对象用在一个if语句中。为了实现这个目的，可以定义一个特别的__nonzero__()方法，它的返回值为True或False,当实例对象处在布尔上下文中的时候这个方法就会被调用。在python3中，仍然可以完成同样的功能，但这个特殊方法的名字改为了__bool__()</p>
<p>比如python2中</p>
<p>class A: def <strong>nonzero</strong>(self): pass</p>
<p>python3中改为： 　 class A: def bool(self)： pass</p>
<p>在布尔上下文使用一个类对象时，python3会调用__bool__().</p>
<p>python2中:</p>
<p>class A: def <strong>nonzero</strong>(self, x, y): pass</p>
<p>这种情况python3中不做改变，使用两个参数的__nonzero__()方法，2to3脚本会假设你定义的这个方法有其他用处，不做修改。</p>
<h2 id="八进制类型"><a class="markdownIt-Anchor" href="#八进制类型"></a> 八进制类型</h2>
<p>python2和python3，定义八进制数的语法有轻微的改变</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x= 0755</td>
<td style="text-align:left">x = 0o755</td>
</tr>
</tbody>
</table>
<h2 id="sysmaxint"><a class="markdownIt-Anchor" href="#sysmaxint"></a> SYS.MAXINT</h2>
<p>python3中长整型和整型被整合到一起，sys.maxint常量不再精确。但是因为这个值用于检查特定平台，所以被python3保留，重命名为sys.maxsize.</p>
<h2 id="全局函数callable"><a class="markdownIt-Anchor" href="#全局函数callable"></a> 全局函数CALLABLE()</h2>
<p>python２里，可以使用全局函数callable()来检查一个对象是否可调用，在python3中，这个全局函数被取消了，为了检查一个对象是否可调用，可以检查其特殊方法__call__()的存在性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">callable(anthing)</td>
<td style="text-align:left">hasattr(anything, ‘<strong>call</strong>’)</td>
</tr>
</tbody>
</table>
<h2 id="全局函数zip"><a class="markdownIt-Anchor" href="#全局函数zip"></a> 全局函数ZIP()</h2>
<p>在python2，zip()可以使用任意多个序列作为参数，它返回一个由元组构成的列表。第一个元组包含了每个序列的第一个元素，第二个元组包含了每个序列的第二个元素，依次递推。在python３中返回一个迭代器，而非列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zip(a,b,c)</td>
<td style="text-align:left">list(zip(a,b,c)</td>
<td style="text-align:left">python3中可以通过list函数遍历zip()返回的迭代器，形成列表返回</td>
</tr>
<tr>
<td style="text-align:left">d.join(zip(a,b,c))</td>
<td style="text-align:left">no change</td>
<td style="text-align:left">在已经会遍历所有元素的上下文环境里，zip()本身返回的迭代器能够正常工作，2to3脚本检测到后，不再修改</td>
</tr>
</tbody>
</table>
<h2 id="standarderror异常"><a class="markdownIt-Anchor" href="#standarderror异常"></a> STANDARDERROR异常</h2>
<p>python2中，StandardError是除了StopIteration,GeneratorExit,KeyboardInterrupt, SystemExit之外所有其他内置异常的基类。python3中StandardError已经被取消了，使用Exception取代。</p>
<h2 id="types模块中的常量"><a class="markdownIt-Anchor" href="#types模块中的常量"></a> TYPES模块中的常量</h2>
<p>types模块里各种各样的常量能够帮助你决定一个对象的类型。在python2里，它包含了代表所有基本数据类型的常量，如dict和int。在python3里，这些常量被取消了，只需使用基础类型的名字来替代。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">types.UnicodeType</td>
<td style="text-align:left">str</td>
</tr>
<tr>
<td style="text-align:left">types.StringType</td>
<td style="text-align:left">bytes</td>
</tr>
<tr>
<td style="text-align:left">types.DictType</td>
<td style="text-align:left">dict</td>
</tr>
<tr>
<td style="text-align:left">types.IntType</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">types.LongType</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">types.ListType</td>
<td style="text-align:left">list</td>
</tr>
<tr>
<td style="text-align:left">types.NoneType</td>
<td style="text-align:left">type(None</td>
</tr>
<tr>
<td style="text-align:left">types.BooleanType</td>
<td style="text-align:left">bool</td>
</tr>
<tr>
<td style="text-align:left">types.BufferType</td>
<td style="text-align:left">memoryview</td>
</tr>
<tr>
<td style="text-align:left">types.ClassType</td>
<td style="text-align:left">type</td>
</tr>
<tr>
<td style="text-align:left">types.ComplexType</td>
<td style="text-align:left">complex</td>
</tr>
<tr>
<td style="text-align:left">types.EllipsisType</td>
<td style="text-align:left">type(Ellipsis)</td>
</tr>
<tr>
<td style="text-align:left">types.FloatType</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">types.ObjectType</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">types.NotImplementedType</td>
<td style="text-align:left">type(NotImplemented)</td>
</tr>
<tr>
<td style="text-align:left">types.SliceType</td>
<td style="text-align:left">slice</td>
</tr>
<tr>
<td style="text-align:left">types.TupleType</td>
<td style="text-align:left">tuple</td>
</tr>
<tr>
<td style="text-align:left">types.TypeType</td>
<td style="text-align:left">type</td>
</tr>
<tr>
<td style="text-align:left">types.XRangeType</td>
<td style="text-align:left">range</td>
</tr>
</tbody>
</table>
<h2 id="全局函数isinstance"><a class="markdownIt-Anchor" href="#全局函数isinstance"></a> 全局函数ISINSTANCE()</h2>
<p>isinstance()函数检查一个对象是否是一个特定类(class)或类型(type)的实例。在python2，可以传递一个由类型构成的元组给isinstance(),如果该对象是元组里的任意一种类型，函数返回True. 在python3,依然可以这样做。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">isinstance(x, (int, float, int))</td>
<td style="text-align:left">isinstance(x, (int, float))</td>
</tr>
</tbody>
</table>
<h2 id="itertools模块"><a class="markdownIt-Anchor" href="#itertools模块"></a> ITERTOOLS模块</h2>
<p>python2.3引入itertools模块，定义了zip(),map(),filter()的变体，这个变体返回的是迭代器，而非列表。在python3,这些函数返回的本身就是迭代器，所有这些变体函数就取消了。</p>
<h2 id="sysexc_typesysexc_valuesysexc_traceback"><a class="markdownIt-Anchor" href="#sysexc_typesysexc_valuesysexc_traceback"></a> SYS.EXC_TYPE,SYS.EXC_VALUE,SYS.EXC_TRACEBACK</h2>
<p>处理异常的时候，在sys模块里有三个你可以访问的变量：sys.exc_type, sys.exc_value, sys.exc_traceback. python3中这三个变量不再存在，使用sys.exc_info替代。</p>
<h2 id="对元组的列表解析"><a class="markdownIt-Anchor" href="#对元组的列表解析"></a> 对元组的列表解析</h2>
<p>python2，如果需要编写一个遍历元组的列表解析，不需要在元组值周围加上括号。在python3里，这些括号是必需的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[ i for i in 1, 2]</td>
<td style="text-align:left">[i for i in (1,2)]</td>
</tr>
</tbody>
</table>
<h2 id="元类"><a class="markdownIt-Anchor" href="#元类"></a> 元类</h2>
<p>在python2里，可以通过在类的声明中定义metaclass参数，或者定义一个特殊的类级别(class-level)__metaclass__属性，来创建元类。python3中，__metaclass__属性被取消了。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">class C(metaclass=PapayaMeta): pass</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class Whip: <strong>metaclass</strong> = PapayMeta</td>
<td style="text-align:left">class Whip(metaclass=PapayaMeta): pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class C(Whipper, Beater): <strong>metaclass</strong> = PapayaMeta</td>
<td style="text-align:left">class C(Whipper, Beater, metaclass=PapayMeta): pass</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>几乎所有的python2程序都需要一些修改才能正常的运行在python3的环境下。为了简化这个转换过程，Python3自带了一个2to3的实用脚本.这个脚本会将python2程序源文件作为输入，然后自动转换到python３．但并不是所有内容都可以自动转换。</p>
<h2 id="print语句-2"><a class="markdownIt-Anchor" href="#print语句-2"></a> print语句</h2>
<p>python2中print是一个语句，不论想输出什么，直接放到print关键字后面即可。python3里，print()是一个函数，像其他函数一样，print()需要你将要输出的东西作为参数传给它。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">print</td>
<td style="text-align:left">print()</td>
<td style="text-align:left">输出一个空白行，python3需要调用不带参数的print()</td>
</tr>
<tr>
<td style="text-align:left">print 1</td>
<td style="text-align:left">print(1)</td>
<td style="text-align:left">输出一个值，将值传入print()函数</td>
</tr>
<tr>
<td style="text-align:left">print 1, 2</td>
<td style="text-align:left">print(1,2)</td>
<td style="text-align:left">输出使用空格分割的两个值，使用两个参数调用print()</td>
</tr>
<tr>
<td style="text-align:left">print 1, 2,</td>
<td style="text-align:left">print(1,2, end=’ ')</td>
<td style="text-align:left">python2中如果使用一个,作为print结尾，将会用空格分割输出的结果，然后在输出一个尾随的空格，而不输回车。python3里，把end=’ ’ 作为一个关键字传给print()可以实现同样的效果，end默认值为’\n’,所以通过重新指定end参数的值，可以取消在末尾输出回车符号</td>
</tr>
<tr>
<td style="text-align:left">print &gt;&gt; sys.stderr, 1, 2, 3</td>
<td style="text-align:left">print(1, 2, 3, file=sys.stderr</td>
<td style="text-align:left">python2中，可以通过&gt;&gt;pipe_name语法，把输出重定向到一个管道，比如sys.stderr.在python3里，可以通过将管道作为关键字参数file的值传递给print()完成同样的功能。</td>
</tr>
</tbody>
</table>
<h2 id="unicode字符串-2"><a class="markdownIt-Anchor" href="#unicode字符串-2"></a> UNICODE字符串</h2>
<p>python2中有两种字符串类型：Unicode字符串和非Unicode字符串。Python3中只有一种类型：Unicode字符串。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u’PapayaWhip’</td>
<td style="text-align:left">‘PapayaWhip’</td>
<td style="text-align:left">python2中的Unicode字符串在python3即为普通字符串</td>
</tr>
<tr>
<td style="text-align:left">ur’PapayaWhip\foo’</td>
<td style="text-align:left">r’PapayWhip\foo’</td>
<td style="text-align:left">Unicode原始字符串(使用这种字符串，python不会自动转义反斜线&quot;&quot;)也被替换为普通的字符串，因为在python3里，所有原始字符串都是以unicode编码的。</td>
</tr>
</tbody>
</table>
<h2 id="全局函数unicode-2"><a class="markdownIt-Anchor" href="#全局函数unicode-2"></a> 全局函数UNICODE()</h2>
<p>python２有两个全局函数可以把对象强制转换成字符串:unicode()把对象转换成unicode字符串，还有str()把对象转换为非Unicode字符串。Python3只有一种字符串类型，unicode字符串，所以str()函数即可完成所有的功能。</p>
<h2 id="long长整型-2"><a class="markdownIt-Anchor" href="#long长整型-2"></a> LONG长整型</h2>
<p>python2有非浮点数准备的int和long类型。int类型最大值不能超过sys.maxint，而且这个最大值是平台相关的。可以通过在数字的末尾附上一个Ｌ来定义长整型，显然，它比int类型表示的数字范围更大。在python3里，只有一种整数类型int,大多数情况下，和python２中的长整型类似。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x = 1000000000000L</td>
<td style="text-align:left">x = 1000000000000</td>
<td style="text-align:left">python2中的十进制长整型在python3中被替换为十进制普通整数</td>
</tr>
<tr>
<td style="text-align:left">x = 0xFFFFFFFFFFFFL</td>
<td style="text-align:left">x = 0xFFFFFFFFFFFF</td>
<td style="text-align:left">python2里的十六进制长整型在python3里被替换为十六进制的普通整数</td>
</tr>
<tr>
<td style="text-align:left">long(x)</td>
<td style="text-align:left">int(x)</td>
<td style="text-align:left">python3没有long()</td>
</tr>
<tr>
<td style="text-align:left">type(x) is long</td>
<td style="text-align:left">type(x) is int</td>
<td style="text-align:left">python3用int判断是否为整型</td>
</tr>
<tr>
<td style="text-align:left">isinstance(x, long)</td>
<td style="text-align:left">isinstance(x, int)</td>
<td style="text-align:left">int检查整数类型</td>
</tr>
</tbody>
</table>
<h2 id="比较运算符-2"><a class="markdownIt-Anchor" href="#比较运算符-2"></a> &lt;&gt;比较运算符</h2>
<p>Python2支持&lt;&gt;作为!=的同义词，　python3只支持!=, 不再支持&lt;&gt;</p>
<h2 id="字典类方法has_key-2"><a class="markdownIt-Anchor" href="#字典类方法has_key-2"></a> 字典类方法HAS_KEY()</h2>
<p>Python2中，字典对象has_key()方法测试字典是否包含指定的键。python3不再支持这个方法，需要使用in.</p>
<h2 id="返回列表的字典类方法-2"><a class="markdownIt-Anchor" href="#返回列表的字典类方法-2"></a> 返回列表的字典类方法</h2>
<p>在python2里，许多字典类方法的返回值是列表。最常用方法有keys, items和values。python3，所有以上方法的返回值改为动态试图。在一些上下文环境里，这种改变不会产生影响。如果这些方法的返回值被立即传递给另外一个函数，而且那个函数会遍历整个序列，那么以上方法的返回值是列表或视图并不会产生什么不同。如果你期望获得一个被独立寻址元素的列表，那么python3的这些改变将会使你的代码卡住，因为视图不支持索引。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a_dictionary.keys()</td>
<td style="text-align:left">list(a_dictionary.keys())</td>
<td style="text-align:left">使用list()将keys 返回值转换为一个静态列表</td>
</tr>
<tr>
<td style="text-align:left">a_dictionary.items()</td>
<td style="text-align:left">list(a_dictonary.items())</td>
<td style="text-align:left">将items返回值转为列表</td>
</tr>
<tr>
<td style="text-align:left">a_dictionary.iterkeys()</td>
<td style="text-align:left">iter(a_dictionary.keys())</td>
<td style="text-align:left">python3不再支持iterkeys,使用iter()将keys()的返回值转换为一个迭代器</td>
</tr>
<tr>
<td style="text-align:left">[i for i in a_dictionary.iterkeys()]</td>
<td style="text-align:left">[ i for i in a_dictonary.keys()]</td>
<td style="text-align:left">不需要使用额外的iter()，keys()方法返回的是可迭代的</td>
</tr>
<tr>
<td style="text-align:left">min(a_dictionary.keys())</td>
<td style="text-align:left">no change</td>
<td style="text-align:left">对min(),max(),sum(),list(),tuple(),set(),sorted(),any()和all()同样有效</td>
</tr>
</tbody>
</table>
<h2 id="重命名或重新组织的模块-2"><a class="markdownIt-Anchor" href="#重命名或重新组织的模块-2"></a> 重命名或重新组织的模块</h2>
<p>从python2到python3，标准库里的一些模块已经被重命名。还有一些相互关联的模块也被组合或则重新组织，使得这种关联更有逻辑性。</p>
<p>HTTP</p>
<p>python3中几个相关的http模块被组合成一个单独的包，即http</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">import httplib</td>
<td style="text-align:left">import http.client</td>
<td style="text-align:left">http.client模块实现一个底层的库，可以用来请求和解析http</td>
</tr>
<tr>
<td style="text-align:left">import cookie</td>
<td style="text-align:left">import http.cookies</td>
<td style="text-align:left">http.cookie提供一个pythonic接口进行cookies操作</td>
</tr>
<tr>
<td style="text-align:left">import cookielib</td>
<td style="text-align:left">import http.cookiejar</td>
<td style="text-align:left">http.cookiejar可以操作cookies文件</td>
</tr>
<tr>
<td style="text-align:left">import BaseHTTPServer import SimpleHTTPServer import CGIHttpServer</td>
<td style="text-align:left">import http.server</td>
<td style="text-align:left">http.server实现了一个基本的http服务器</td>
</tr>
</tbody>
</table>
<p>URLLIB</p>
<p>python2中用来分析、编码和获取URL的模块，但是比较混乱，python3中，这些模块被重构，组合成为一个单独的包，即urllib</p>
<p>| python2 | python3 | 备注 | import urllib | import urllib.request, import urllb.parse, import urllib.error | | import urllib2 | import urllib.request, urllib.error | | import urlparse | import urllib.parse | | import robotparser | import urllib.robotparser | | from urllib import FancyURLopener | from urllib.rquest import FancyURLopener from urllib.parse | |from urllib2 import Request from urllib2 import HTTPError | from urllib.request import Request from urllib.error import HTTPError |</p>
<p>DBM</p>
<p>所有的DBM现在都在一个单独的包里，即dbm。如果需要其中某个特定的变体，比如GNU DBM,可以导入dbm包中合适的模块。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">import dbm</td>
<td style="text-align:left">import dbm.ndbm</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import gdbm</td>
<td style="text-align:left">import dbm.gnu</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import dbhash</td>
<td style="text-align:left">import dbm.bad</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import dumbdbm</td>
<td style="text-align:left">import dbm.dumb</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import anydbm import whichdb</td>
<td style="text-align:left">import dbm</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>XMLRPC</p>
<p>XML-RPC是一个通过HTTP协议执行远程RPC调用的轻重级方法。一些XML_RPC客户端和XML_RPC服务端的实现库组合成独立的包，xmlrpc.</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">import xmlrpclib</td>
<td style="text-align:left">import xmlrpc.client</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import DocXMLRPCServer import SimpleXMLRPCServer</td>
<td style="text-align:left">import xmlrpc.server</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>其他模块</p>
<table>
<thead>
<tr>
<th style="text-align:left">Python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">try: import cStringIO as StringIO except ImportError: import STringIO</td>
<td style="text-align:left">import io</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import cPickle as pickle except ImportError: import pickle</td>
<td style="text-align:left">import pickle</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import builtin</td>
<td style="text-align:left">import builtins</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import copy_reg</td>
<td style="text-align:left">import copyreg</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import Queue</td>
<td style="text-align:left">import queue</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import SocketServer</td>
<td style="text-align:left">import socketserver</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import ConfigParser</td>
<td style="text-align:left">import configparser</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import repr</td>
<td style="text-align:left">import reprlib</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">import commands</td>
<td style="text-align:left">import subprocess</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>包内的相对导入</p>
<p>包是由一组相关联的模块共同组成的单个实体。在python２的时候，为了实现同一个包内模块的相互引用，你会使用import foo或者from foo import Bar。<a target="_blank" rel="noopener" href="http://xn--Python2foo-jy4pi3s7sdluumwc5y3c9az31rpx5fr6zaz79cvlvbtba.py">Python2解释器会先在当前目录里搜索foo.py</a>，然后再去python搜索路径(sys.path)搜索。在python3里这个过程有一点不同。Python3不会首先在当前路径搜索，它会直接在Python的搜索路径里寻找。如果想要包里的一个模块导入包的另一个模块，需要显式的提供两个模块的相对路径。</p>
<p>迭代器方法NEXT()</p>
<p>python2里，迭代器有一个next()方法，用来返回序列的下一项。在python3里同样成立。但是有一个新的全局的函数next(),它使用一个迭代器作为参数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">anIterator.next()</td>
<td style="text-align:left">next(anIterator)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_function_that_returns_an_iterator().next()</td>
<td style="text-align:left">next(a_function_that_returns_an_iterator())</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class A: def next(self): pass</td>
<td style="text-align:left">class A : def next(self): pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class A: def next(self, x, y): pass</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">next = 42 for an_iterator in a_sequence_of_iterators: an_iterator.next()</td>
<td style="text-align:left">next =42 for an interator in a_sequence_of_iterators: an_iterator.next()</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>全局函数FILTER()</p>
<p>在python2里，filter()方法返回一个列表，这个列表是通过一个返回值为True或False的函数来检测序列里的每一项的道德。在python3中，filter()函数返回一个迭代器，不再是列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">filter(a_function, a_sequence)</td>
<td style="text-align:left">list(filter(a_function, a_sequence))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">list(filter(a_function, a_sequence))</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">filter(None, a_sequence)</td>
<td style="text-align:left">[i for i in a_sequence if i ]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">for i in filter(None, a_sequence):</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[i for i in filter(a_function, a_sequence)]</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>MAP()</p>
<p>跟filter()的改变一样，map()函数现在返回一个迭代器,python2中返回一个列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">map(a_function,‘PapayaWhip’</td>
<td style="text-align:left">list(map(a_function, ‘PapayaWhip’))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">map(None, ‘PapayaWhip’</td>
<td style="text-align:left">list(‘PapayWhip’)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">map(lambda x: x+1, range(42))</td>
<td style="text-align:left">[x+1 for x in range(42)]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">for i in map(a_function, a_sequence):</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[i for i in map(a_function, a_sequence)]</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>REDUCE()</p>
<p>在python3里，reduce()函数已经从全局名字空间移除，现在被放置在fucntools模块里。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">reduce(a,b,c)</td>
<td style="text-align:left">from functools import reduce reduce(a, b, c)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>APPLY()</p>
<p>python2有一个叫做apply()的全局函数，它使用一个函数f和一个列表[a,b,c]作为参数，返回值是f(a,b,c).可以直接调用这个函数，在列表前添加一个星号作为参数传递给它来完成同样的事情。在python3里，apply()函数不再存在；必须使用星号标记。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">apply(a_function, a_list_of_args</td>
<td style="text-align:left">a_function(*a_list_of_args)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">apply(a_function, a_list_of_args, a_dictionary_of_named_args)</td>
<td style="text-align:left">a_function(*a_list_of_args, **a_dictionary_of_named_args)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">apply(a_function, a_list_of_args + z)</td>
<td style="text-align:left">a_function(*a_list_of_args + z)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">apply(aModule.a_function, a_list_of_args)</td>
<td style="text-align:left">aModule.a_function(*a_list_of_args)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>INTERN()  python2里，你可以用intern()函数作用在一个字符串上来限定intern以达到性能优化，python3里，intern()函数转移到sys模块里。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">intern(aString)</td>
<td style="text-align:left">sys.intern(aString)</td>
<td style="text-align:left">--------</td>
</tr>
</tbody>
</table>
<p>EXEC</p>
<p>就像print语句在python3里变成了一个函数一样，exec语句也是这样的。exec()函数使用一个包含任意python代码的字符串作为参数，然后像执行语句或表达式一样执行它。exec()跟eval()是相似，但exec()更加强大并具有挑战性。eval()函数只能执行单独一条表达式，但是exec()能够执行多条语句，导入(import),函数声明－实际上整个python程序的字符串表示也可以。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">exec codeString</td>
<td style="text-align:left">exec(codeString)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">exec codeString in a_global_namespace</td>
<td style="text-align:left">exec(codeString, a_global_namespace)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">exec_codeString in a_global_namespace, a_local_namespace</td>
<td style="text-align:left">exec(codeString, a_global_namespace, a_local_namespace</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>execfile</p>
<p>python２中的execfile语句可以像执行python代码那样使用字符串。不同的是exec使用字符串，而execfile使用文件。在python3，execfile语句被去掉了。</p>
<p>REPR</p>
<p>在python2，为了得到一个任意对象的字符串表示，有一种把对象包装在反引号里(比如<code>x</code>)的特殊语法。在python3里，这种能力仍然存在，但是你不能再使用反引号获得这种字符串表示了，需要使用全局函数repr().</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x</code></td>
<td style="text-align:left">repr(x)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>'PapayaWhip' +</code>2``</td>
<td style="text-align:left">repr(‘PapayWhip’ + repr(2))</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>TRYEXCEPT语句</p>
<p>python２到python3，捕获异常的语法有些变化。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Python2</th>
<th style="text-align:left">Python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">try: import mymodule except ImportError, e pass</td>
<td style="text-align:left">try: import mymodule except ImportError as e: pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import mymodule except (RuntimeError, ImportError), e pass</td>
<td style="text-align:left">try: import mymodule except(RuntimeError, ImportError) as e: pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import mymodule except ImportError: pass</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">try: import mymodule except: pass</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>RAISE</p>
<p>python3里，抛出自定义异常的语法有细微的变化。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">raise MyException</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">raise MyException, ‘error message’</td>
<td style="text-align:left">raise MyException(‘error message’)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">raise MyException, ‘error message’</td>
<td style="text-align:left">raise MyException(‘error message’).with_traceback(a_traceback)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">raise ‘error message’</td>
<td style="text-align:left">unsupported</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>生成器THROW</p>
<p>在python2里，生成器有一个throw()方法。调用a_generator.throw()会在生成器被暂停的时候抛出异常，然后返回由生成器函数获取的下一个值。python3中，这一功能仍然可用，但语法有一点不同。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a_generator.throw(MyException)</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_generator.throw(MyException, ‘error message’</td>
<td style="text-align:left">a_generator.throw(MyException(‘error message’))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_generator.throw(‘error message’)</td>
<td style="text-align:left">unsupported</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>XRANGE()</p>
<p>python２里，有两种方法获得一定范围内的数字：range(),返回一个列表，还有xrange(),返回一个迭代器。python3　里，range()返回迭代器，xrange()不再存在。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xrange(10)</td>
<td style="text-align:left">range(10)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">a_list = range(10)</td>
<td style="text-align:left">a_list= list(range(10))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[i for i in xrange(10)]</td>
<td style="text-align:left">[i for i in range(10)]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">for i in range(10):</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">sum(range(10))</td>
<td style="text-align:left">no change</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="raw_input和input-2"><a class="markdownIt-Anchor" href="#raw_input和input-2"></a> RAW_INPUT()和INPUT()</h2>
<p>python2有两个全局函数，用在命令行请求用户输入。第一个叫input()，它等待用户输入一个python表达式(然后返回结果)。第二个叫做raw_input(),用户输入什么他就返回什么。python3 通过input替代了他们。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">raw_input()</td>
<td style="text-align:left">input</td>
<td style="text-align:left">input替代了raw_input</td>
</tr>
<tr>
<td style="text-align:left">raw_input(‘prompt’)</td>
<td style="text-align:left">input(‘prompt’)</td>
<td style="text-align:left">python3仍然支持提示符参数</td>
</tr>
<tr>
<td style="text-align:left">input()</td>
<td style="text-align:left">eval(input))</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="函数属性func_-2"><a class="markdownIt-Anchor" href="#函数属性func_-2"></a> 函数属性FUNC_*</h2>
<p>python2,函数的代码可用访问到函数本身的特殊属性。python3为了一致性，这些特殊属性被重命名了。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a_function.func_name</td>
<td style="text-align:left">a_function.<strong>name</strong></td>
<td style="text-align:left">__name__属性包含了函数的名字</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_doc</td>
<td style="text-align:left">a_function.<strong>doc</strong></td>
<td style="text-align:left">__doc__包含了函数源代码定义的文档字符串</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_defaults</td>
<td style="text-align:left">a_function.<strong>defaults</strong></td>
<td style="text-align:left">是一个保存参数默认值的元组</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_dict</td>
<td style="text-align:left">a_function.<strong>dict</strong></td>
<td style="text-align:left">__dict__属性是一个支持任意函数属性的名字空间</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_closure</td>
<td style="text-align:left">a_function.<strong>closure</strong></td>
<td style="text-align:left">__closure__属性是由cell对象组成的元组，包含了函数对自由变量的绑定</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_globals</td>
<td style="text-align:left">a_function.<strong>globals</strong></td>
<td style="text-align:left">是对模块全局名字空间的引用</td>
</tr>
<tr>
<td style="text-align:left">a_function.func_code</td>
<td style="text-align:left">a_function.<strong>code</strong></td>
<td style="text-align:left">是一个代码对象，表示编译后的函数体</td>
</tr>
</tbody>
</table>
<h2 id="io方法xreadlines-2"><a class="markdownIt-Anchor" href="#io方法xreadlines-2"></a> I/O方法XREADLINES()</h2>
<p>python2中，文件对象有一个xreadlines()方法，返回一个迭代器，一次读取文件的一行。这在for循环中尤其实用。python3中，xreadlines()方法不再可用。</p>
<h2 id="lambda函数-2"><a class="markdownIt-Anchor" href="#lambda函数-2"></a> lambda函数</h2>
<p>在python2中，可以定义匿名函数lambda函数，通过指定作为参数的元组的元素个数，使这个函数实际上能够接收多个参数。python2的解释器把这个元组&quot;解开“成命名参数，然后可以在lambda函数里引用它们。在python3中仍然可以传递一个元组为lambda函数的参数。但是python解释器不会把它当成解析成命名参数。需要通过位置索引来引用每个参数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">lambda (x,): x + f(x)</td>
<td style="text-align:left">lambda x1 : x1[0] + f(x1[0])</td>
<td style="text-align:left">注１</td>
</tr>
<tr>
<td style="text-align:left">lambda (x,y): x + f(y)</td>
<td style="text-align:left">lambda x_y : x_y[0] + f(x_y[1])</td>
<td style="text-align:left">注２</td>
</tr>
<tr>
<td style="text-align:left">lambda (x,(y,z)): x + y + z</td>
<td style="text-align:left">lambda x_y_z: x_y_z[0] + x_y_z[1][0]+ x_y_z[1][1]</td>
<td style="text-align:left">注３</td>
</tr>
<tr>
<td style="text-align:left">lambda x,y,z: x+y+z</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left">注４</td>
</tr>
</tbody>
</table>
<p>注１：如果定义了一个lambda函数，使用包含一个元素的元组作为参数，python3中，会被转换成一个包含到x1[0]的引用的lambda函数。x1是2to3脚本基于原来元组里的命名参数自动生成的。</p>
<p>注２：使用含有两个元素的元组(x,y)作为参数的lambda函数被转换为x_y,它有两个位置参数，即x_y[0]和x_y[1]</p>
<p>注３：2to3脚本可以处理使用嵌套命名参数的元组作为参数的lambda函数。产生的结果有点晦涩，但python3下和python2的效果是一样的。</p>
<p>注４：可以定义使用多个参数的lambda函数。语法在python3同样有效</p>
<h2 id="特殊的方法属性-2"><a class="markdownIt-Anchor" href="#特殊的方法属性-2"></a> 特殊的方法属性</h2>
<p>在python2里，类方法可以访问到定义他们的类对象,也能访问方法对象本身。im_self是类的实例对象；im_func是函数对象，im_class是类本身。在python3里，这些属性被重命名，以遵循其他属性的命名约定。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">aClassInstance.aClassMethod.im_func</td>
<td style="text-align:left">aClassInstance.aClassMethod.<strong>func</strong></td>
</tr>
<tr>
<td style="text-align:left">aClassInstance.aClassMethod.im_self</td>
<td style="text-align:left">aClassInstance.aClassMethod.<strong>self</strong></td>
</tr>
<tr>
<td style="text-align:left">aClassInstance.aClassMethod.im_class</td>
<td style="text-align:left">aClassInstance.aClassMethod.<strong>self</strong>.<strong>class</strong></td>
</tr>
</tbody>
</table>
<h2 id="__nonzero__特殊方法-2"><a class="markdownIt-Anchor" href="#__nonzero__特殊方法-2"></a> __NONZERO__特殊方法</h2>
<p>在python2里，可以创建自己的类，并使他们能够在布尔上下文中使用。举例来说，可以实例化这个类，并把这个实例对象用在一个if语句中。为了实现这个目的，可以定义一个特别的__nonzero__()方法，它的返回值为True或False,当实例对象处在布尔上下文中的时候这个方法就会被调用。在python3中，仍然可以完成同样的功能，但这个特殊方法的名字改为了__bool__()</p>
<p>比如python2中</p>
<p>class A: def <strong>nonzero</strong>(self): pass</p>
<p>python3中改为： 　 class A: def bool(self)： pass</p>
<p>在布尔上下文使用一个类对象时，python3会调用__bool__().</p>
<p>python2中:</p>
<p>class A: def <strong>nonzero</strong>(self, x, y): pass</p>
<p>这种情况python3中不做改变，使用两个参数的__nonzero__()方法，2to3脚本会假设你定义的这个方法有其他用处，不做修改。</p>
<h2 id="八进制类型-2"><a class="markdownIt-Anchor" href="#八进制类型-2"></a> 八进制类型</h2>
<p>python2和python3，定义八进制数的语法有轻微的改变</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x= 0755</td>
<td style="text-align:left">x = 0o755</td>
</tr>
</tbody>
</table>
<h2 id="sysmaxint-2"><a class="markdownIt-Anchor" href="#sysmaxint-2"></a> SYS.MAXINT</h2>
<p>python3中长整型和整型被整合到一起，sys.maxint常量不再精确。但是因为这个值用于检查特定平台，所以被python3保留，重命名为sys.maxsize.</p>
<h2 id="全局函数callable-2"><a class="markdownIt-Anchor" href="#全局函数callable-2"></a> 全局函数CALLABLE()</h2>
<p>python２里，可以使用全局函数callable()来检查一个对象是否可调用，在python3中，这个全局函数被取消了，为了检查一个对象是否可调用，可以检查其特殊方法__call__()的存在性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">callable(anthing)</td>
<td style="text-align:left">hasattr(anything, ‘<strong>call</strong>’)</td>
</tr>
</tbody>
</table>
<h2 id="全局函数zip-2"><a class="markdownIt-Anchor" href="#全局函数zip-2"></a> 全局函数ZIP()</h2>
<p>在python2，zip()可以使用任意多个序列作为参数，它返回一个由元组构成的列表。第一个元组包含了每个序列的第一个元素，第二个元组包含了每个序列的第二个元素，依次递推。在python３中返回一个迭代器，而非列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zip(a,b,c)</td>
<td style="text-align:left">list(zip(a,b,c)</td>
<td style="text-align:left">python3中可以通过list函数遍历zip()返回的迭代器，形成列表返回</td>
</tr>
<tr>
<td style="text-align:left">d.join(zip(a,b,c))</td>
<td style="text-align:left">no change</td>
<td style="text-align:left">在已经会遍历所有元素的上下文环境里，zip()本身返回的迭代器能够正常工作，2to3脚本检测到后，不再修改</td>
</tr>
</tbody>
</table>
<h2 id="standarderror异常-2"><a class="markdownIt-Anchor" href="#standarderror异常-2"></a> STANDARDERROR异常</h2>
<p>python2中，StandardError是除了StopIteration,GeneratorExit,KeyboardInterrupt, SystemExit之外所有其他内置异常的基类。python3中StandardError已经被取消了，使用Exception取代。</p>
<h2 id="types模块中的常量-2"><a class="markdownIt-Anchor" href="#types模块中的常量-2"></a> TYPES模块中的常量</h2>
<p>types模块里各种各样的常量能够帮助你决定一个对象的类型。在python2里，它包含了代表所有基本数据类型的常量，如dict和int。在python3里，这些常量被取消了，只需使用基础类型的名字来替代。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">types.UnicodeType</td>
<td style="text-align:left">str</td>
</tr>
<tr>
<td style="text-align:left">types.StringType</td>
<td style="text-align:left">bytes</td>
</tr>
<tr>
<td style="text-align:left">types.DictType</td>
<td style="text-align:left">dict</td>
</tr>
<tr>
<td style="text-align:left">types.IntType</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">types.LongType</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">types.ListType</td>
<td style="text-align:left">list</td>
</tr>
<tr>
<td style="text-align:left">types.NoneType</td>
<td style="text-align:left">type(None</td>
</tr>
<tr>
<td style="text-align:left">types.BooleanType</td>
<td style="text-align:left">bool</td>
</tr>
<tr>
<td style="text-align:left">types.BufferType</td>
<td style="text-align:left">memoryview</td>
</tr>
<tr>
<td style="text-align:left">types.ClassType</td>
<td style="text-align:left">type</td>
</tr>
<tr>
<td style="text-align:left">types.ComplexType</td>
<td style="text-align:left">complex</td>
</tr>
<tr>
<td style="text-align:left">types.EllipsisType</td>
<td style="text-align:left">type(Ellipsis)</td>
</tr>
<tr>
<td style="text-align:left">types.FloatType</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">types.ObjectType</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">types.NotImplementedType</td>
<td style="text-align:left">type(NotImplemented)</td>
</tr>
<tr>
<td style="text-align:left">types.SliceType</td>
<td style="text-align:left">slice</td>
</tr>
<tr>
<td style="text-align:left">types.TupleType</td>
<td style="text-align:left">tuple</td>
</tr>
<tr>
<td style="text-align:left">types.TypeType</td>
<td style="text-align:left">type</td>
</tr>
<tr>
<td style="text-align:left">types.XRangeType</td>
<td style="text-align:left">range</td>
</tr>
</tbody>
</table>
<h2 id="全局函数isinstance-2"><a class="markdownIt-Anchor" href="#全局函数isinstance-2"></a> 全局函数ISINSTANCE()</h2>
<p>isinstance()函数检查一个对象是否是一个特定类(class)或类型(type)的实例。在python2，可以传递一个由类型构成的元组给isinstance(),如果该对象是元组里的任意一种类型，函数返回True. 在python3,依然可以这样做。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">isinstance(x, (int, float, int))</td>
<td style="text-align:left">isinstance(x, (int, float))</td>
</tr>
</tbody>
</table>
<h2 id="itertools模块-2"><a class="markdownIt-Anchor" href="#itertools模块-2"></a> ITERTOOLS模块</h2>
<p>python2.3引入itertools模块，定义了zip(),map(),filter()的变体，这个变体返回的是迭代器，而非列表。在python3,这些函数返回的本身就是迭代器，所有这些变体函数就取消了。</p>
<h2 id="sysexc_typesysexc_valuesysexc_traceback-2"><a class="markdownIt-Anchor" href="#sysexc_typesysexc_valuesysexc_traceback-2"></a> SYS.EXC_TYPE,SYS.EXC_VALUE,SYS.EXC_TRACEBACK</h2>
<p>处理异常的时候，在sys模块里有三个你可以访问的变量：sys.exc_type, sys.exc_value, sys.exc_traceback. python3中这三个变量不再存在，使用sys.exc_info替代。</p>
<h2 id="对元组的列表解析-2"><a class="markdownIt-Anchor" href="#对元组的列表解析-2"></a> 对元组的列表解析</h2>
<p>python2，如果需要编写一个遍历元组的列表解析，不需要在元组值周围加上括号。在python3里，这些括号是必需的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[ i for i in 1, 2]</td>
<td style="text-align:left">[i for i in (1,2)]</td>
</tr>
</tbody>
</table>
<h2 id="元类-2"><a class="markdownIt-Anchor" href="#元类-2"></a> 元类</h2>
<p>在python2里，可以通过在类的声明中定义metaclass参数，或者定义一个特殊的类级别(class-level)__metaclass__属性，来创建元类。python3中，__metaclass__属性被取消了。</p>
<table>
<thead>
<tr>
<th style="text-align:left">python2</th>
<th style="text-align:left">python3</th>
<th style="text-align:left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">class C(metaclass=PapayaMeta): pass</td>
<td style="text-align:left">unchanged</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class Whip: <strong>metaclass</strong> = PapayMeta</td>
<td style="text-align:left">class Whip(metaclass=PapayaMeta): pass</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">class C(Whipper, Beater): <strong>metaclass</strong> = PapayaMeta</td>
<td style="text-align:left">class C(Whipper, Beater, metaclass=PapayMeta): pass</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="post-meta__tags" href="tags/python/">python</a><a class="post-meta__tags" href="tags/%E4%BB%A3%E7%A0%81/">代码</a></div><div class="post_share"><div class="social-share" data-image="/private_img/banner2.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/private_img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/private_img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/private_img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/private_img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="101587567.html" title="python做计量"><img class="cover" src="/private_img/banner2.gif" onerror="onerror=null;src='/private_img/banner.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python做计量</div></div></a></div><div class="next-post pull-right"><a href="1837523341.html" title="stata笔记"><img class="cover" src="/private_img/banner2.gif" onerror="onerror=null;src='/private_img/banner.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">stata笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="4095312961.html" title="MATLAB与代数式"><img class="cover" src="/private_img/banner2.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-19</div><div class="title">MATLAB与代数式</div></div></a></div><div><a href="1837523341.html" title="stata笔记"><img class="cover" src="/private_img/banner2.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-15</div><div class="title">stata笔记</div></div></a></div><div><a href="101587567.html" title="python做计量"><img class="cover" src="/private_img/banner2.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-15</div><div class="title">python做计量</div></div></a></div><div><a href="5504202.html" title="python数据处理手册"><img class="cover" src="/private_img/banner2.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-23</div><div class="title">python数据处理手册</div></div></a></div><div><a href="3805420524.html" title="助教：一键登记提交和成绩"><img class="cover" src="/private_img/banner2.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-16</div><div class="title">助教：一键登记提交和成绩</div></div></a></div><div><a href="3845945498.html" title="高级计量经济学课件"><img class="cover" src="/private_img/banner2.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-24</div><div class="title">高级计量经济学课件</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="../private_img/yuyingnan.jpg" onerror="this.onerror=null;this.src='../private_img/404.gif'" alt="avatar"/></div><div class="author-info__name">揭晓</div><div class="author-info__description">随手写一写，揭晓这世界</div></div><a id="card-info-btn" href="/"><i class="fas fa-home"></i><span>回到首页</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#print%E8%AF%AD%E5%8F%A5"><span class="toc-text"> print语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unicode%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> UNICODE字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0unicode"><span class="toc-text"> 全局函数UNICODE()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#long%E9%95%BF%E6%95%B4%E5%9E%8B"><span class="toc-text"> LONG长整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> &lt;&gt;比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E7%B1%BB%E6%96%B9%E6%B3%95has_key"><span class="toc-text"> 字典类方法HAS_KEY()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E7%9A%84%E5%AD%97%E5%85%B8%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text"> 返回列表的字典类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%88%96%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-text"> 重命名或重新组织的模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raw_input%E5%92%8Cinput"><span class="toc-text"> RAW_INPUT()和INPUT()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7func_"><span class="toc-text"> 函数属性FUNC_*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%96%B9%E6%B3%95xreadlines"><span class="toc-text"> I&#x2F;O方法XREADLINES()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="toc-text"> lambda函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7"><span class="toc-text"> 特殊的方法属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#__nonzero__%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95"><span class="toc-text"> __NONZERO__特殊方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 八进制类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysmaxint"><span class="toc-text"> SYS.MAXINT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0callable"><span class="toc-text"> 全局函数CALLABLE()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0zip"><span class="toc-text"> 全局函数ZIP()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#standarderror%E5%BC%82%E5%B8%B8"><span class="toc-text"> STANDARDERROR异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#types%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="toc-text"> TYPES模块中的常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0isinstance"><span class="toc-text"> 全局函数ISINSTANCE()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#itertools%E6%A8%A1%E5%9D%97"><span class="toc-text"> ITERTOOLS模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysexc_typesysexc_valuesysexc_traceback"><span class="toc-text"> SYS.EXC_TYPE,SYS.EXC_VALUE,SYS.EXC_TRACEBACK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%85%83%E7%BB%84%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90"><span class="toc-text"> 对元组的列表解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B1%BB"><span class="toc-text"> 元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#print%E8%AF%AD%E5%8F%A5-2"><span class="toc-text"> print语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unicode%E5%AD%97%E7%AC%A6%E4%B8%B2-2"><span class="toc-text"> UNICODE字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0unicode-2"><span class="toc-text"> 全局函数UNICODE()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#long%E9%95%BF%E6%95%B4%E5%9E%8B-2"><span class="toc-text"> LONG长整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6-2"><span class="toc-text"> &lt;&gt;比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E7%B1%BB%E6%96%B9%E6%B3%95has_key-2"><span class="toc-text"> 字典类方法HAS_KEY()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E7%9A%84%E5%AD%97%E5%85%B8%E7%B1%BB%E6%96%B9%E6%B3%95-2"><span class="toc-text"> 返回列表的字典类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%88%96%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E7%9A%84%E6%A8%A1%E5%9D%97-2"><span class="toc-text"> 重命名或重新组织的模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raw_input%E5%92%8Cinput-2"><span class="toc-text"> RAW_INPUT()和INPUT()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7func_-2"><span class="toc-text"> 函数属性FUNC_*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%96%B9%E6%B3%95xreadlines-2"><span class="toc-text"> I&#x2F;O方法XREADLINES()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0-2"><span class="toc-text"> lambda函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7-2"><span class="toc-text"> 特殊的方法属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#__nonzero__%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95-2"><span class="toc-text"> __NONZERO__特殊方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B-2"><span class="toc-text"> 八进制类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysmaxint-2"><span class="toc-text"> SYS.MAXINT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0callable-2"><span class="toc-text"> 全局函数CALLABLE()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0zip-2"><span class="toc-text"> 全局函数ZIP()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#standarderror%E5%BC%82%E5%B8%B8-2"><span class="toc-text"> STANDARDERROR异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#types%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F-2"><span class="toc-text"> TYPES模块中的常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0isinstance-2"><span class="toc-text"> 全局函数ISINSTANCE()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#itertools%E6%A8%A1%E5%9D%97-2"><span class="toc-text"> ITERTOOLS模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysexc_typesysexc_valuesysexc_traceback-2"><span class="toc-text"> SYS.EXC_TYPE,SYS.EXC_VALUE,SYS.EXC_TRACEBACK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%85%83%E7%BB%84%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90-2"><span class="toc-text"> 对元组的列表解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B1%BB-2"><span class="toc-text"> 元类</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../2511924152.html" title="博士论文手稿">博士论文手稿</a><time datetime="2023-03-08T04:06:51.581Z" title="更新于 2023-03-08 12:06:51">2023-03-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../449942006.html" title="创新理论梳理">创新理论梳理</a><time datetime="2023-03-08T04:06:51.579Z" title="更新于 2023-03-08 12:06:51">2023-03-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../584278389.html" title="Git教程">Git教程</a><time datetime="2023-03-07T10:37:04.264Z" title="更新于 2023-03-07 18:37:04">2023-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../1386118935.html" title="哈维反资本世界简史">哈维反资本世界简史</a><time datetime="2023-03-07T10:33:58.555Z" title="更新于 2023-03-07 18:33:58">2023-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../1837695103.html" title="总书记金句">总书记金句</a><time datetime="2023-03-07T10:33:58.555Z" title="更新于 2023-03-07 18:33:58">2023-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../2442454912.html" title="windows注册表">windows注册表</a><time datetime="2023-03-07T10:33:58.552Z" title="更新于 2023-03-07 18:33:58">2023-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../4065962852.html" title="龙治铭量化分析课件">龙治铭量化分析课件</a><time datetime="2023-03-07T10:32:10.871Z" title="更新于 2023-03-07 18:32:10">2023-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../4237846169.html" title="高级计量进阶——残差相关的各种情形">高级计量进阶——残差相关的各种情形</a><time datetime="2023-03-07T10:32:10.871Z" title="更新于 2023-03-07 18:32:10">2023-03-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/private_img/banner2.gif')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 揭晓</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="js/utils.js"></script><script src="js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://dhndzwxj.github.io/2928949794.html'
    this.page.identifier = ''
    this.page.title = 'python2 与 python3的区别'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://https-www-dhndzwxj-top.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script type='text/javascript' src='https://ajax.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js'></script><script id="dsq-count-scr" src="//https-www-dhndzwxj-top.disqus.com/count.js" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="../js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>